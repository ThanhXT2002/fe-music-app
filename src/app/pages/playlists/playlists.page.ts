import {
  Component,
  OnInit,
  OnDestroy,
  ViewChild,
  ElementRef,
  signal,
  effect, // Add effect import
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { Album, Song } from '../../interfaces/song.interface';
import { AudioPlayerService } from '../../services/audio-player.service';
import { PlaylistsPageStateService } from 'src/app/services/playlists-page-state.service';
import { PlaylistService } from '../../services/playlist.service'; // ‚ú® Updated import
import { Subject, takeUntil } from 'rxjs';
import { RefreshService } from 'src/app/services/refresh.service';
import { AlertController } from '@ionic/angular'; // ‚ú® Add AlertController for modal
import { FormsModule } from '@angular/forms';
import { MediaCardComponent } from "../../components/media-card/media-card.component";

@Component({
  selector: 'app-playlists',
  templateUrl: './playlists.page.html',
  styleUrls: ['./playlists.page.scss'],
  standalone: true,
  imports: [CommonModule, RouterLink, FormsModule, MediaCardComponent]
})
export class PlaylistsPage implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  @ViewChild('scrollContainer', { static: false }) scrollContainer!: ElementRef;
  @ViewChild('playlistNameInput') playlistNameInput!: ElementRef<HTMLInputElement>;

  // Track active playlist
  activePlaylist = signal<string | null>(null);

  currentSong: Song | null = null;

  constructor(
    private audioPlayerService: AudioPlayerService,
    public playlistsState: PlaylistsPageStateService,
    private refreshService: RefreshService,
    private playlistService: PlaylistService, // ‚ú® Updated to use PlaylistService
    private alertController: AlertController // ‚ú® Inject AlertController
  ) {
    // Setup effect to watch current song changes
    this.setupCurrentSongWatcher();
  }

  async ngOnInit() {
    // Restore scroll position if available
    setTimeout(() => {
      if (this.scrollContainer && this.playlistsState.scrollPosition > 0) {
        this.scrollContainer.nativeElement.scrollTop =
          this.playlistsState.scrollPosition;
      }
    }, 100);

    // Load playlists if not already loaded
    if (!this.playlistsState.isDataLoaded) {
      await this.loadPlaylists();
    }

    // L·∫Øng nghe t√≠n hi·ªáu refresh
    this.refreshService.refresh$
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.loadPlaylists();
      });
  }

  ngOnDestroy() {
    // Save scroll position when leaving the page
    if (this.scrollContainer) {
      this.playlistsState.setScrollPosition(
        this.scrollContainer.nativeElement.scrollTop
      );
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  async loadPlaylists() {
    try {
      // ‚ú® Use PlaylistService instead of manual grouping
      const playlists = await this.playlistService.getAllArtistPlaylists();
      this.playlistsState.setPlaylists(playlists);
    } catch (error) {
      console.error('Error loading playlists:', error);
    }
  }
  async playPlaylist(playlist: Album, event: Event) {
    event.stopPropagation();

    if (playlist.songs.length > 0) {
      await this.audioPlayerService.setPlaylist(playlist.songs, 0);
    }
  }

  openPlaylist(playlist: Album) {
    // TODO: Navigate to playlist detail page
    console.log('Open playlist:', playlist.name);
  }

  // Wrapper methods for MediaCardComponent events
  async onPlaylistClick(item: any) {
    const playlist = item as Album;
    // Play playlist directly when clicked
    if (playlist.songs.length > 0) {
      await this.audioPlayerService.setPlaylist(playlist.songs, 0);
    }
  }

  onPlaylistMenuClick(event: {item: any, event: Event}) {
    this.showPlaylistContextMenu(event.item as Album, event.event);
  }

  formatDuration(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else {
      return `${minutes}m`;
    }
  }

  trackByPlaylistId(index: number, playlist: Album): string {
    return playlist.id;
  }
  // ‚ú® Show create playlist modal
  async showCreatePlaylistModal() {
    const alert = await this.alertController.create({
      mode: 'ios',
      header: 'T·∫°o Playlist M·ªõi',
      inputs: [
        {
          name: 'name',
          type: 'text',
          placeholder: 'Playlist name',
          attributes: {
            required: true,
          },
        },
      ],
      buttons: [
        {
          text: 'H·ªßy',
          role: 'cancel',
        },
        {
          text: 'L∆∞u',
          handler: async (data) => {
            if (data.name) {
              await this.createNewPlaylist(data.name, data.description);
              return true;
            }
            return false;
          },
        },
      ],
    });

    await alert.present();
  }
  // ‚ú® Create new playlist (artist-based)
  private async createNewPlaylist(name: string, description?: string) {
    try {
      const newPlaylist = await this.playlistService.createArtistPlaylist({
        name: name, // Artist name becomes playlist name
        description: description,
      });

      if (newPlaylist) {
        // Refresh playlists list
        await this.loadPlaylists();
        console.log('Playlist created successfully:', newPlaylist.name);

        // Show success message
        const successAlert = await this.alertController.create({
          mode: 'ios',
          header: 'Th√†nh C√¥ng',
          message: `Playlist "${name}" ƒë√£ ƒë∆∞·ª£c t·∫°o!`,
          buttons: ['OK'],
        });
        await successAlert.present();
      } else {
        throw new Error('Failed to create playlist');
      }
    } catch (error) {
      console.error('Error creating playlist:', error);

      // Show error message
      const errorAlert = await this.alertController.create({
        mode: 'ios',
        header: 'L·ªói',
        message: 'Kh√¥ng th·ªÉ t·∫°o playlist. Vui l√≤ng th·ª≠ l·∫°i.',
        buttons: ['OK'],
      });
      await errorAlert.present();
    }
  }

  // ‚ú® Show playlist context menu for user-created playlists
  async showPlaylistContextMenu(playlist: Album, event: Event) {
    event.stopPropagation();

    if (!playlist.isUserCreated) {
      return; // Only for user-created playlists
    }
    const alert = await this.alertController.create({
      mode: 'ios',
      header: playlist.name,
      buttons: [
        {
          text: '‚úèÔ∏è Ch·ªânh s·ª≠a Playlist',
          handler: () => {
            this.editPlaylist(playlist);
          },
        },
        {
          text: '‚ûï Th√™m nh·∫°c v√†o Playlist',
          handler: () => {
            this.showAddSongsToPlaylist(playlist);
          },
        },
        {
          text: 'üóëÔ∏è X√≥a Playlist',
          role: 'destructive',
          handler: () => {
            this.confirmDeletePlaylist(playlist);
          },
        },
        {
          text: 'ƒê√≥ng',
          role: 'cancel',
        },
      ],
    });

    await alert.present();
  }  // ‚ú® Edit playlist information (artist-based)
  async editPlaylist(playlist: Album) {
    const alert = await this.alertController.create({
      mode: 'ios',
      header: 'Ch·ªânh s·ª≠a Playlist',
      inputs: [
        {
          name: 'name',
          type: 'text',
          placeholder: 'T√™n playlist',
          value: playlist.name, // Playlist name is artist name
          attributes: {
            required: true,
          },
        },
        {
          name: 'description',
          type: 'textarea',
          placeholder: 'Playlist description (optional)',
          value: playlist.description || '',
        },
      ],
      buttons: [
        {
          text: 'H·ªßy',
          role: 'cancel',
        },
        {
          text: 'L∆∞u',
          handler: async (data) => {
            if (data.name) {
              await this.updatePlaylist(
                playlist.id,
                data.name,
                data.description
              );
              return true;
            }
            return false;
          },
        },
      ],
    });

    await alert.present();
  }
  // ‚ú® Update playlist (artist-based)
  private async updatePlaylist(
    playlistId: string,
    playlistName: string,
    description?: string
  ) {
    try {
      const success = await this.playlistService.updateArtistPlaylist(playlistId, {
        name: playlistName, // Artist name becomes playlist name
        description: description,
      });

      if (success) {
        await this.loadPlaylists();
        console.log('Playlist updated successfully');

        const successAlert = await this.alertController.create({
          mode: 'ios',
          header: 'Th√†nh C√¥ng',
          message: 'Playlist ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng!',
          buttons: ['OK'],
        });
        await successAlert.present();
      } else {
        throw new Error('Failed to update playlist');
      }
    } catch (error) {
      console.error('Error updating playlist:', error);

      const errorAlert = await this.alertController.create({
        mode: 'ios',
        header: 'L·ªói',
        message: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t playlist. Vui l√≤ng th·ª≠ l·∫°i.',
        buttons: ['OK'],
      });
      await errorAlert.present();
    }
  }

  // ‚ú® Show add songs to playlist
  async showAddSongsToPlaylist(playlist: Album) {
    // TODO: Implement add songs interface
    // For now, show a placeholder message
    const alert = await this.alertController.create({
      mode: 'ios',
      header: 'Th√™m Nh·∫°c v√†o Playlist',
      message:
        'Ch·ª©c nƒÉng n√†y s·∫Ω s·ªõm ƒë∆∞·ª£c c·∫≠p nh·∫≠t. Hi·ªán t·∫°i b·∫°n c√≥ th·ªÉ th√™m b√†i h√°t v√†o playlist th√¥ng qua trang chi ti·∫øt playlist.',
      buttons: ['OK'],
    });
    await alert.present();
  }

  // ‚ú® Confirm delete playlist
  async confirmDeletePlaylist(playlist: Album) {
    const alert = await this.alertController.create({
      mode: 'ios',
      header: 'X√≥a Playlist',
      message: `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a playlist "${playlist.name}"?`,
      buttons: [
        {
          text: 'H·ªßy',
          role: 'cancel',
        },
        {
          text: 'X√≥a',
          role: 'destructive',
          handler: async () => {
            await this.deletePlaylist(playlist.id);
          },
        },
      ],
    });

    await alert.present();
  }

  // ‚ú® Delete playlist
  private async deletePlaylist(playlistId: string) {
    try {
      const success = await this.playlistService.deleteArtistPlaylist(playlistId);

      if (success) {
        await this.loadPlaylists();
        console.log('Playlist deleted successfully');

        const successAlert = await this.alertController.create({
          mode: 'ios',
          header: 'Th√†nh C√¥ng',
          message: 'Playlist ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!',
          buttons: ['OK'],
        });
        await successAlert.present();
      } else {
        throw new Error('Failed to delete playlist');
      }
    } catch (error) {
      console.error('Error deleting playlist:', error);

      const errorAlert = await this.alertController.create({
        mode: 'ios',
        header: 'L·ªói',
        message: 'Kh√¥ng th·ªÉ x√≥a playlist. Vui l√≤ng th·ª≠ l·∫°i.',
        buttons: ['OK'],
      });
      await errorAlert.present();
    }
  }

  onImageError(event: any): void {
    event.target.src = 'assets/images/musical-note.webp';
  }

  // ‚úÖ Setup effect to watch current song changes
  private setupCurrentSongWatcher() {
    effect(() => {
      this.currentSong = this.audioPlayerService.currentSong();
      if (this.currentSong) {
        // Find which playlist contains the current song
        const currentPlaylist = this.playlistsState.playlists.find((playlist: Album) =>
          playlist.songs.some((song: Song) => song.id === this.currentSong?.id)
        );
        this.activePlaylist.set(currentPlaylist ? currentPlaylist.name : null);
      } else {
        this.activePlaylist.set(null);
      }
    });
  }

  // ‚ú® Check if playlist is active
  isPlaylistActive(playlist: Album): boolean {
    const active = this.activePlaylist();
    return active === playlist.name;
  }
}
