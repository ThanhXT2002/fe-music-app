import { Injectable, inject } from '@angular/core';
import { Album, Song } from '../interfaces/song.interface';
import { Playlist } from '../interfaces/playlist.interface';
import { PlaylistService } from './playlist.service';
import { DatabaseService } from './database.service';

@Injectable({
  providedIn: 'root'
})
export class AlbumService {
  private playlistService = inject(PlaylistService);
  private databaseService = inject(DatabaseService);

  /**
   * Get all albums (auto-generated + user-created)
   */
  async getAllAlbums(): Promise<Album[]> {
    try {
      // Get auto-generated albums from songs
      const autoGeneratedAlbums = await this.getAutoGeneratedAlbums();

      // Get user-created albums from playlists
      const userCreatedAlbums = await this.getUserCreatedAlbums();

      // Combine and sort
      const allAlbums = [...autoGeneratedAlbums, ...userCreatedAlbums];
      return this.sortAlbums(allAlbums);
    } catch (error) {
      console.error('Error getting all albums:', error);
      return [];
    }
  }

  /**
   * Auto-generate albums from songs (read-only)
   */
  private async getAutoGeneratedAlbums(): Promise<Album[]> {
    try {
      const songs = await this.databaseService.getAllSongs();
      return this.groupSongsIntoAlbums(songs);
    } catch (error) {
      console.error('Error getting auto-generated albums:', error);
      return [];
    }
  }

  /**
   * Get user-created albums (stored as playlists)
   */
  private async getUserCreatedAlbums(): Promise<Album[]> {
    try {
      // Get all playlists with type 'album'
      const playlists = await this.playlistService.getAllPlaylists();
      const albumPlaylists = playlists.filter(p =>
        p.description?.startsWith('__ALBUM__') || // Special marker for album-playlists
        p.name.includes('[Album]') // Alternative identification
      );

      return albumPlaylists.map(playlist => this.convertPlaylistToAlbum(playlist));
    } catch (error) {
      console.error('Error getting user-created albums:', error);
      return [];
    }
  }
  /**
   * Create new user album (artist-based)
   */
  async createAlbum(albumData: {
    name: string; // Artist name
    description?: string;
    thumbnail?: string;
    songs?: Song[];
  }): Promise<Album | null> {
    try {
      const playlist = await this.playlistService.createPlaylist({
        name: albumData.name, // Use artist name as album name
        description: `__ALBUM__${albumData.name}__${albumData.description || ''}`,
        thumbnail: albumData.thumbnail,
        type: 'user'
      });

      if (playlist) {
        // Add songs if provided
        if (albumData.songs && albumData.songs.length > 0) {
          const songIds = albumData.songs.map(song => song.id);
          await this.playlistService.addSongsToPlaylist(playlist.id, songIds);
        }

        return this.convertPlaylistToAlbum(playlist);
      }
      return null;
    } catch (error) {
      console.error('Error creating album:', error);
      return null;
    }
  }  /**
   * Update existing album (artist-based)
   */
  async updateAlbum(albumId: string, updates: Partial<Album>): Promise<boolean> {
    try {
      // Check if it's user-created album
      const album = await this.getAlbumById(albumId);
      if (!album?.isUserCreated) {
        throw new Error('Cannot update auto-generated album');
      }

      const playlistUpdates: Partial<Pick<Playlist, 'name' | 'description' | 'thumbnail'>> = {
        name: updates.name, // Artist name becomes album name
        description: updates.description ? `__ALBUM__${updates.name || album.name}__${updates.description}` : undefined,
        thumbnail: updates.thumbnail
      };

      return await this.playlistService.updatePlaylistInfo(albumId, playlistUpdates);
    } catch (error) {
      console.error('Error updating album:', error);
      return false;
    }
  }

  /**
   * Delete user-created album
   */
  async deleteAlbum(albumId: string): Promise<boolean> {
    try {
      const album = await this.getAlbumById(albumId);
      if (!album?.isUserCreated) {
        throw new Error('Cannot delete auto-generated album');
      }

      return await this.playlistService.deletePlaylist(albumId);
    } catch (error) {
      console.error('Error deleting album:', error);
      return false;
    }
  }
  /**
   * Add song to album
   */
  async addSongToAlbum(albumId: string, song: Song): Promise<boolean> {
    try {
      const album = await this.getAlbumById(albumId);
      if (!album?.isUserCreated) {
        throw new Error('Cannot modify auto-generated album');
      }

      return await this.playlistService.addSongToPlaylist(albumId, song.id);
    } catch (error) {
      console.error('Error adding song to album:', error);
      return false;
    }
  }

  /**
   * Remove song from album
   */
  async removeSongFromAlbum(albumId: string, songId: string): Promise<boolean> {
    try {
      const album = await this.getAlbumById(albumId);
      if (!album?.isUserCreated) {
        throw new Error('Cannot modify auto-generated album');
      }

      return await this.playlistService.removeSongFromPlaylist(albumId, songId);
    } catch (error) {
      console.error('Error removing song from album:', error);
      return false;
    }
  }

  /**
   * Get album by ID
   */
  async getAlbumById(albumId: string): Promise<Album | null> {
    try {
      // Try user-created first
      const playlist = await this.playlistService.getPlaylistById(albumId);
      if (playlist && playlist.description?.startsWith('__ALBUM__')) {
        return this.convertPlaylistToAlbum(playlist);
      }

      // Fall back to auto-generated
      const allAlbums = await this.getAutoGeneratedAlbums();
      return allAlbums.find(album => album.id === albumId) || null;
    } catch (error) {
      console.error('Error getting album by ID:', error);
      return null;
    }
  }
  /**
   * Helper: Group songs into auto-generated albums (by artist)
   */
  private groupSongsIntoAlbums(songs: Song[]): Album[] {
    const albumMap = new Map<string, Album>();

    songs.forEach((song) => {
      const artistName = song.artist || 'Unknown Artist';
      const albumKey = artistName; // Use artist name as key

      if (!albumMap.has(albumKey)) {
        albumMap.set(albumKey, {
          id: `auto_album_${this.sanitizeString(artistName)}`,
          name: artistName, // Artist name becomes album name
          artist: artistName, // Same as name for consistency
          thumbnail: song.thumbnail,
          songs: [],
          genre: song.genre,
          totalDuration: 0,
          isUserCreated: false,
          isEditable: false,
          createdDate: new Date(),
          updatedDate: new Date()
        });
      }

      const album = albumMap.get(albumKey)!;
      album.songs.push(song);
      album.totalDuration += song.duration;

      if (!album.thumbnail && song.thumbnail) {
        album.thumbnail = song.thumbnail;
      }
    });

    return Array.from(albumMap.values());
  }
  /**
   * Helper: Convert Playlist to Album (artist-based)
   */
  private convertPlaylistToAlbum(playlist: Playlist): Album {
    // Parse artist from description: __ALBUM__ARTIST__DESCRIPTION
    const parts = playlist.description?.split('__') || [];
    const artistName = parts[2] || playlist.name || 'Unknown Artist';
    const description = parts.slice(3).join('__') || '';

    return {
      id: playlist.id,
      name: artistName, // Use artist name as album name
      artist: artistName, // Same as name for consistency
      thumbnail: playlist.thumbnail,
      songs: playlist.songs,
      totalDuration: playlist.songs.reduce((sum, song) => sum + song.duration, 0),
      description: description || undefined,
      isUserCreated: true,
      isEditable: true,
      createdDate: playlist.createdDate,
      updatedDate: playlist.updatedDate
    };
  }

  /**
   * Helper: Sort albums
   */
  private sortAlbums(albums: Album[]): Album[] {
    return albums.sort((a, b) => {
      // User-created albums first
      if (a.isUserCreated !== b.isUserCreated) {
        return (b.isUserCreated ? 1 : 0) - (a.isUserCreated ? 1 : 0);
      }

      // Then by artist, then by name
      if (a.artist !== b.artist) {
        return a.artist.localeCompare(b.artist);
      }
      return a.name.localeCompare(b.name);
    });
  }

  /**
   * Helper: Generate unique album ID
   */
  private generateAlbumId(): string {
    return `user_album_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Helper: Sanitize string for use in IDs
   */
  private sanitizeString(str: string): string {
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
  }
}
